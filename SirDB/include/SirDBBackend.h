// /////////////////////////////////////////////////////////////////////
// Program: SirDB
// Version: 1.0
// File:    SirDBBackend.h
// Authors: Jordan Carlson (Caltech), Claudio Grandi (INFN BO)
// Date:    26/09/2004
// Note:
// /////////////////////////////////////////////////////////////////////

#ifndef SIRDB_BACKEND
#define SIRDB_BACKEND

#include <string>
#include <vector>


class SirDBResultRow;
typedef SirDBResultRow SirDBResultHeaders;
class SirDBResultSet;
class SirDBResultSetData;


/***** DatabaseBackend *****/

class SirDBBackend {
public:
  /* Create a new database backend. The actual type will depend on what
     backend Boss was configured to use. */
  static SirDBBackend* create(const std::string& config, const std::string& mode = "");

  virtual ~SirDBBackend() {}

  /* Connect to the database (using previously established connection
     parameters). Return 0 on success. */
  virtual int connect() = 0;

  /* Disconnect from the database. */
  virtual void disconnect() = 0;

  /* Perform a general query, ignoring the results.
     Return 0 on success, negative if an error occurs. */
  virtual int query(const std::string& q) = 0;

  /* Perform a SELECT (or similary) query and return the result set.
     If an error occurs, the result set evaluates to false. */
  virtual SirDBResultSet fetch_query(const std::string& q) = 0;

  /* Perform a query and return the number of affected rows (for an INSERT-like
     query) or the number of rows in the result set (for a SELECT-like query).
     Return 0 if no rows were affected, negative if an error occurs. */
  virtual int rowcount_query(const std::string& q) = 0;

  /* Perform an INSERT or UPDATE query, and return the unique ID generated by
     the AUTO_INCREMENT column.
     Return 0 if no rows are affected, negative if an error occurs. */
  virtual int insert_query(const std::string& q) = 0;

  /* Escape the given string so that it can be inserted into the database. */
  virtual std::string escape(std::string s) = 0;
  virtual std::string escape(const char* s, size_t len) = 0;

  /* Return a string describing the last error encountered by the database.
     Return the empty string if there wasn't an error. */
  virtual std::string errormsg() = 0;

};


/***** ResultSet *****/

class SirDBResultSet {
public:
  SirDBResultSet();
  SirDBResultSet(const SirDBResultSet& results);
  SirDBResultSet(SirDBResultSetData* data);
  ~SirDBResultSet();
  SirDBResultSet& operator=(const SirDBResultSet& results);

  operator bool() const;
  size_t nrows() const;
  size_t nfields() const;
  SirDBResultRow operator[](unsigned int i);
  SirDBResultHeaders headers() const;

private:
  SirDBResultSetData* _data;
  const std::vector<std::vector<char*> >* _rows;
};


/***** ResultRow *****/

class SirDBResultRow {
public:
  SirDBResultRow();

  size_t nfields() const;
  const char* operator[](unsigned int j) const;

private:
  SirDBResultSet _results;
  const std::vector<char*>* _row;

  friend class SirDBResultSet;
  SirDBResultRow(SirDBResultSet results, const std::vector<char*>* _row);
};


/***** _ResultSetData *****/

class SirDBResultSetData {
public:
  int refs;
  SirDBResultSetData()              { refs = 0; }
  virtual ~SirDBResultSetData()     {}
  void incref()                 { ++refs; }
  void decref()                 { if(--refs == 0) delete this; }

  /* These data members must be set in the derived class constructor. */
  size_t nrows;
  size_t nfields;

  /* These methods must be defined by the derived class. */
  virtual const std::vector<std::vector<char*> >* getrows() = 0;
  virtual const std::vector<char*>* getheaders() = 0;
};


/***** Inline implementation of ResultSet *****/

inline SirDBResultSet::SirDBResultSet() {
  _data = 0;
  _rows = 0;
}

inline SirDBResultSet::SirDBResultSet(const SirDBResultSet& results) {
  _data = results._data;
  _rows = results._rows;
  if(_data)
    _data->incref();
}

inline SirDBResultSet::SirDBResultSet(SirDBResultSetData* data) {
  _data = data;
  _rows = 0;
  if(_data)
    _data->incref();
}

inline SirDBResultSet::~SirDBResultSet() {
  if(_data)
    _data->decref();
}

inline SirDBResultSet& SirDBResultSet::operator=(const SirDBResultSet& results) {
  if(results._data)
    results._data->incref();
  if(_data)
    _data->decref();
  _data = results._data;
  _rows = results._rows;
  return *this;
}

inline SirDBResultSet::operator bool() const {
  return (_data != 0);
}

inline size_t SirDBResultSet::nrows() const {
  return (_data == 0) ? 0 : _data->nrows;
}

inline size_t SirDBResultSet::nfields() const {
  return (_data == 0) ? 0 : _data->nfields;
}

inline SirDBResultRow SirDBResultSet::operator[](unsigned int i) {
  if(_data == 0)
    return SirDBResultRow(*this, 0);
  else {
    if(_rows == 0)
      _rows = _data->getrows();
    return SirDBResultRow(*this, &(*_rows)[i]);
  }
}

inline SirDBResultHeaders SirDBResultSet::headers() const {
  return (_data == 0) ? SirDBResultHeaders(*this, 0)
                         : SirDBResultHeaders(*this, _data->getheaders());
}


/***** Inline implementation of ResultRow *****/

inline SirDBResultRow::SirDBResultRow() {
  _results = 0;
  _row = 0;
}

inline SirDBResultRow::SirDBResultRow(SirDBResultSet results, const std::vector<char *>* row) {
  _results = results;
  _row = row;
}

inline size_t SirDBResultRow::nfields() const {
  return _results ? _results.nfields() : 0;
}

inline const char* SirDBResultRow::operator[](unsigned int j) const {
  return _row ? (*_row)[j] : 0;
}

#endif // DATABASE_BACKEND
